"""Execute model-generated Python code in a restricted sandbox.

This module provides a simple sandbox for executing Python code generated by the model.
It uses a restricted `exec()` with limited builtins and registered external functions.

Note: This is a pragmatic implementation for training validation. For production, consider
upgrading to Monty (Pydantic's Rust-based sandbox) when it reaches stable API (> v0.0.3).
"""

from __future__ import annotations

import ast
import io
import sys
from contextlib import redirect_stdout
from dataclasses import dataclass
from typing import TYPE_CHECKING, Callable

if TYPE_CHECKING:
    from punie.agent.typed_tools import TypeCheckResult


@dataclass(frozen=True)
class ExternalFunctions:
    """Registry of external functions available in sandbox.

    These functions bridge from the sandbox back to ACP tools.
    """

    read_file: Callable[[str], str]
    write_file: Callable[[str, str], str]
    run_command: Callable[[str, list[str] | None, str | None], str]
    typecheck: Callable[[str], TypeCheckResult]


class CodeExecutionError(Exception):
    """Raised when code execution fails (syntax error, runtime error, etc)."""

    pass


def _validate_code(code: str) -> None:
    """Validate Python code syntax before execution.

    Args:
        code: Python source code to validate

    Raises:
        CodeExecutionError: If code has syntax errors
    """
    try:
        ast.parse(code)
    except SyntaxError as exc:
        raise CodeExecutionError(f"Syntax error: {exc}") from exc


def _create_restricted_builtins() -> dict:
    """Create a restricted set of builtins for sandbox.

    Returns:
        Dict of safe builtins (no file I/O, no imports, no system access)
    """
    # Safe builtins - removed dangerous ones like __import__, open, exec, eval
    safe_builtins = {
        # Type conversions
        "int": int,
        "float": float,
        "str": str,
        "bool": bool,
        "list": list,
        "dict": dict,
        "set": set,
        "tuple": tuple,
        # Utilities
        "len": len,
        "range": range,
        "enumerate": enumerate,
        "zip": zip,
        "map": map,
        "filter": filter,
        "sorted": sorted,
        "sum": sum,
        "min": min,
        "max": max,
        "abs": abs,
        "round": round,
        # String operations
        "print": print,
        "repr": repr,
        # Iteration
        "iter": iter,
        "next": next,
        # Type checking
        "isinstance": isinstance,
        "type": type,
        # Exceptions (read-only, can't raise new types)
        "Exception": Exception,
        "ValueError": ValueError,
        "KeyError": KeyError,
        "IndexError": IndexError,
        "TypeError": TypeError,
    }
    return safe_builtins


def run_code(code: str, external_functions: ExternalFunctions) -> str:
    """Execute Python code in a restricted sandbox with external functions.

    Args:
        code: Python source code to execute
        external_functions: Registry of external functions (read_file, write_file, run_command)

    Returns:
        Captured stdout from code execution

    Raises:
        CodeExecutionError: If code validation or execution fails

    Example:
        >>> def fake_read(path: str) -> str:
        ...     return "test content"
        >>> def fake_write(path: str, content: str) -> str:
        ...     return "success"
        >>> def fake_run(cmd: str, args=None, cwd=None) -> str:
        ...     return "output"
        >>> funcs = ExternalFunctions(fake_read, fake_write, fake_run)
        >>> result = run_code('content = read_file("test.txt"); print(content)', funcs)
        >>> result.strip()
        'test content'
    """
    import json

    # Validate syntax first
    _validate_code(code)

    # Create namespace with restricted builtins + external functions + safe modules
    namespace = {
        "__builtins__": _create_restricted_builtins(),
        "read_file": external_functions.read_file,
        "write_file": external_functions.write_file,
        "run_command": external_functions.run_command,
        "typecheck": external_functions.typecheck,
        "json": json,  # Available directly, no import needed
    }

    # Capture stdout
    stdout_capture = io.StringIO()

    try:
        with redirect_stdout(stdout_capture):
            exec(code, namespace)  # noqa: S102 - Intentional use in sandbox
    except Exception as exc:
        raise CodeExecutionError(f"Runtime error: {exc}") from exc

    return stdout_capture.getvalue()


async def run_code_async(code: str, external_functions: ExternalFunctions) -> str:
    """Async wrapper for run_code (for compatibility with async toolset).

    Args:
        code: Python source code to execute
        external_functions: Registry of external functions

    Returns:
        Captured stdout from code execution

    Raises:
        CodeExecutionError: If code validation or execution fails

    Note:
        Currently runs code synchronously. In future, could use async exec or
        run in thread pool for true async execution.
    """
    return run_code(code, external_functions)
