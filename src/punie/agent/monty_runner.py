"""Execute model-generated Python code in a restricted sandbox.

This module provides a simple sandbox for executing Python code generated by the model.
It uses a restricted `exec()` with limited builtins and registered external functions.

Note: This is a pragmatic implementation for training validation. For production, consider
upgrading to Monty (Pydantic's Rust-based sandbox) when it reaches stable API (> v0.0.3).
"""

from __future__ import annotations

import ast
import io
from contextlib import redirect_stdout
from dataclasses import dataclass
from typing import TYPE_CHECKING, Callable

if TYPE_CHECKING:
    from punie.agent.typed_tools import (
        CstAddImportResult,
        CstFindResult,
        CstRenameResult,
        DocumentSymbolsResult,
        FindReferencesResult,
        GitDiffResult,
        GitLogResult,
        GitStatusResult,
        GotoDefinitionResult,
        HoverResult,
        RuffResult,
        TestResult,
        TypeCheckResult,
        WorkspaceSymbolsResult,
    )
    from punie.cst.domain_models import DomainValidationResult


@dataclass(frozen=True)
class ExternalFunctions:
    """Registry of external functions available in sandbox.

    These functions bridge from the sandbox back to ACP tools and typed tools.
    """

    read_file: Callable[[str], str]
    write_file: Callable[[str, str], str]
    run_command: Callable[[str, list[str] | None, str | None], str]
    typecheck: Callable[[str], TypeCheckResult]
    ruff_check: Callable[[str], RuffResult]
    pytest_run: Callable[[str], TestResult]
    goto_definition: Callable[[str, int, int, str], GotoDefinitionResult]
    find_references: Callable[[str, int, int, str], FindReferencesResult]
    hover: Callable[[str, int, int, str], HoverResult]
    document_symbols: Callable[[str], DocumentSymbolsResult]
    workspace_symbols: Callable[[str], WorkspaceSymbolsResult]
    git_status: Callable[[str], GitStatusResult]
    git_diff: Callable[[str, bool], GitDiffResult]
    git_log: Callable[[str, int], GitLogResult]
    # LibCST code tools (Phase 32)
    cst_find_pattern: Callable[[str, str], CstFindResult]
    cst_rename: Callable[[str, str, str], CstRenameResult]
    cst_add_import: Callable[[str, str], CstAddImportResult]
    # Domain validators (Phase 32)
    validate_component: Callable[[str], DomainValidationResult]
    check_render_tree: Callable[[str], DomainValidationResult]
    validate_escape_context: Callable[[str], DomainValidationResult]
    validate_service_registration: Callable[[str], DomainValidationResult]
    check_dependency_graph: Callable[[str], DomainValidationResult]
    validate_injection_site: Callable[[str], DomainValidationResult]
    validate_middleware_chain: Callable[[str], DomainValidationResult]
    check_di_template_binding: Callable[[str], DomainValidationResult]
    validate_route_pattern: Callable[[str], DomainValidationResult]


class CodeExecutionError(Exception):
    """Raised when code execution fails (syntax error, runtime error, etc)."""

    pass


def _validate_code(code: str) -> None:
    """Validate Python code syntax before execution.

    Args:
        code: Python source code to validate

    Raises:
        CodeExecutionError: If code has syntax errors
    """
    try:
        ast.parse(code)
    except SyntaxError as exc:
        raise CodeExecutionError(f"Syntax error: {exc}") from exc


def _create_restricted_builtins() -> dict:
    """Create a restricted set of builtins for sandbox.

    Returns:
        Dict of safe builtins (no file I/O, no imports, no system access)
    """
    # Safe builtins - removed dangerous ones like __import__, open, exec, eval
    safe_builtins = {
        # Type conversions
        "int": int,
        "float": float,
        "str": str,
        "bool": bool,
        "list": list,
        "dict": dict,
        "set": set,
        "tuple": tuple,
        # Utilities
        "len": len,
        "range": range,
        "enumerate": enumerate,
        "zip": zip,
        "map": map,
        "filter": filter,
        "sorted": sorted,
        "sum": sum,
        "min": min,
        "max": max,
        "abs": abs,
        "round": round,
        # String operations
        "print": print,
        "repr": repr,
        # Iteration
        "iter": iter,
        "next": next,
        # Type checking
        "isinstance": isinstance,
        "type": type,
        # Exceptions (read-only, can't raise new types)
        "Exception": Exception,
        "ValueError": ValueError,
        "KeyError": KeyError,
        "IndexError": IndexError,
        "TypeError": TypeError,
    }
    return safe_builtins


def run_code(code: str, external_functions: ExternalFunctions) -> str:
    """Execute Python code in a restricted sandbox with external functions.

    Args:
        code: Python source code to execute
        external_functions: Registry of external functions (read_file, write_file, run_command)

    Returns:
        Captured stdout from code execution

    Raises:
        CodeExecutionError: If code validation or execution fails

    Example:
        >>> from punie.agent.typed_tools import RuffResult, TestResult, TypeCheckResult
        >>> def fake_read(path: str) -> str:
        ...     return "test content"
        >>> def fake_write(path: str, content: str) -> str:
        ...     return "success"
        >>> def fake_run(cmd: str, args=None, cwd=None) -> str:
        ...     return "output"
        >>> def fake_typecheck(path: str) -> TypeCheckResult:
        ...     return TypeCheckResult(success=True, error_count=0, warning_count=0, errors=[])
        >>> def fake_ruff(path: str) -> RuffResult:
        ...     return RuffResult(success=True, violation_count=0, fixable_count=0, violations=[])
        >>> def fake_pytest(path: str) -> TestResult:
        ...     return TestResult(success=True, passed=0, failed=0, errors=0, skipped=0, duration=0.0, tests=[])
        >>> def fake_goto_definition(file_path: str, line: int, col: int, symbol: str) -> GotoDefinitionResult:
        ...     from punie.agent.typed_tools import GotoDefinitionResult
        ...     return GotoDefinitionResult(success=False, symbol=symbol, locations=[])
        >>> def fake_find_references(file_path: str, line: int, col: int, symbol: str) -> FindReferencesResult:
        ...     from punie.agent.typed_tools import FindReferencesResult
        ...     return FindReferencesResult(success=False, symbol=symbol, reference_count=0, references=[])
        >>> def fake_hover(file_path: str, line: int, col: int, symbol: str) -> HoverResult:
        ...     from punie.agent.typed_tools import HoverResult
        ...     return HoverResult(success=False, symbol=symbol)
        >>> def fake_document_symbols(file_path: str) -> DocumentSymbolsResult:
        ...     from punie.agent.typed_tools import DocumentSymbolsResult
        ...     return DocumentSymbolsResult(success=False, file_path=file_path, symbols=[])
        >>> def fake_workspace_symbols(query: str) -> WorkspaceSymbolsResult:
        ...     from punie.agent.typed_tools import WorkspaceSymbolsResult
        ...     return WorkspaceSymbolsResult(success=False, query=query, symbols=[])
        >>> def fake_git_status(path: str) -> GitStatusResult:
        ...     from punie.agent.typed_tools import GitStatusResult
        ...     return GitStatusResult(success=True, clean=True, file_count=0, files=[])
        >>> def fake_git_diff(path: str, staged: bool) -> GitDiffResult:
        ...     from punie.agent.typed_tools import GitDiffResult
        ...     return GitDiffResult(success=True, file_count=0, additions=0, deletions=0, files=[])
        >>> def fake_git_log(path: str, count: int) -> GitLogResult:
        ...     from punie.agent.typed_tools import GitLogResult
        ...     return GitLogResult(success=True, commits=[], commit_count=0)
        >>> def fake_cst_find(fp: str, pat: str): ...
        >>> def fake_cst_rename(fp: str, old: str, new: str): ...
        >>> def fake_cst_add_import(fp: str, stmt: str): ...
        >>> def fake_domain(fp: str): ...
        >>> funcs = ExternalFunctions(
        ...     read_file=fake_read, write_file=fake_write, run_command=fake_run,
        ...     typecheck=fake_typecheck, ruff_check=fake_ruff, pytest_run=fake_pytest,
        ...     goto_definition=fake_goto_definition, find_references=fake_find_references,
        ...     hover=fake_hover, document_symbols=fake_document_symbols,
        ...     workspace_symbols=fake_workspace_symbols, git_status=fake_git_status,
        ...     git_diff=fake_git_diff, git_log=fake_git_log,
        ...     cst_find_pattern=fake_cst_find, cst_rename=fake_cst_rename,
        ...     cst_add_import=fake_cst_add_import, validate_component=fake_domain,
        ...     check_render_tree=fake_domain, validate_escape_context=fake_domain,
        ...     validate_service_registration=fake_domain, check_dependency_graph=fake_domain,
        ...     validate_injection_site=fake_domain, validate_middleware_chain=fake_domain,
        ...     check_di_template_binding=fake_domain, validate_route_pattern=fake_domain,
        ... )
        >>> result = run_code('content = read_file("test.txt"); print(content)', funcs)
        >>> result.strip()
        'test content'
    """
    import json

    # Validate syntax first
    _validate_code(code)

    # Create namespace with restricted builtins + external functions + safe modules
    namespace = {
        "__builtins__": _create_restricted_builtins(),
        "read_file": external_functions.read_file,
        "write_file": external_functions.write_file,
        "run_command": external_functions.run_command,
        "typecheck": external_functions.typecheck,
        "ruff_check": external_functions.ruff_check,
        "pytest_run": external_functions.pytest_run,
        "goto_definition": external_functions.goto_definition,
        "find_references": external_functions.find_references,
        "hover": external_functions.hover,
        "document_symbols": external_functions.document_symbols,
        "workspace_symbols": external_functions.workspace_symbols,
        "git_status": external_functions.git_status,
        "git_diff": external_functions.git_diff,
        "git_log": external_functions.git_log,
        # LibCST code tools
        "cst_find_pattern": external_functions.cst_find_pattern,
        "cst_rename": external_functions.cst_rename,
        "cst_add_import": external_functions.cst_add_import,
        # Domain validators
        "validate_component": external_functions.validate_component,
        "check_render_tree": external_functions.check_render_tree,
        "validate_escape_context": external_functions.validate_escape_context,
        "validate_service_registration": external_functions.validate_service_registration,
        "check_dependency_graph": external_functions.check_dependency_graph,
        "validate_injection_site": external_functions.validate_injection_site,
        "validate_middleware_chain": external_functions.validate_middleware_chain,
        "check_di_template_binding": external_functions.check_di_template_binding,
        "validate_route_pattern": external_functions.validate_route_pattern,
        "json": json,  # Available directly, no import needed
    }

    # Capture stdout
    stdout_capture = io.StringIO()

    try:
        with redirect_stdout(stdout_capture):
            exec(code, namespace)  # noqa: S102 - Intentional use in sandbox
    except Exception as exc:
        raise CodeExecutionError(f"Runtime error: {exc}") from exc

    return stdout_capture.getvalue()


async def run_code_async(code: str, external_functions: ExternalFunctions) -> str:
    """Async wrapper for run_code (for compatibility with async toolset).

    Args:
        code: Python source code to execute
        external_functions: Registry of external functions

    Returns:
        Captured stdout from code execution

    Raises:
        CodeExecutionError: If code validation or execution fails

    Note:
        Currently runs code synchronously. In future, could use async exec or
        run in thread pool for true async execution.
    """
    return run_code(code, external_functions)
